// Generated by gencpp from file no_rcm_key_publisher_msgs/no_rcm_key_publisher_msgs.msg
// DO NOT EDIT!


#ifndef NO_RCM_KEY_PUBLISHER_MSGS_MESSAGE_NO_RCM_KEY_PUBLISHER_MSGS_H
#define NO_RCM_KEY_PUBLISHER_MSGS_MESSAGE_NO_RCM_KEY_PUBLISHER_MSGS_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace no_rcm_key_publisher_msgs
{
template <class ContainerAllocator>
struct no_rcm_key_publisher_msgs_
{
  typedef no_rcm_key_publisher_msgs_<ContainerAllocator> Type;

  no_rcm_key_publisher_msgs_()
    : move_left(false)
    , move_right(false)
    , move_up(false)
    , move_down(false)
    , move_upward(false)
    , move_downward(false)
    , move_forward(false)
    , move_backward(false)
    , move_angle_insertion(false)
    , move_angle_retraction(false)
    , large_gain(false)
    , small_gain(false)
    , small_push(false)  {
    }
  no_rcm_key_publisher_msgs_(const ContainerAllocator& _alloc)
    : move_left(false)
    , move_right(false)
    , move_up(false)
    , move_down(false)
    , move_upward(false)
    , move_downward(false)
    , move_forward(false)
    , move_backward(false)
    , move_angle_insertion(false)
    , move_angle_retraction(false)
    , large_gain(false)
    , small_gain(false)
    , small_push(false)  {
  (void)_alloc;
    }



   typedef uint8_t _move_left_type;
  _move_left_type move_left;

   typedef uint8_t _move_right_type;
  _move_right_type move_right;

   typedef uint8_t _move_up_type;
  _move_up_type move_up;

   typedef uint8_t _move_down_type;
  _move_down_type move_down;

   typedef uint8_t _move_upward_type;
  _move_upward_type move_upward;

   typedef uint8_t _move_downward_type;
  _move_downward_type move_downward;

   typedef uint8_t _move_forward_type;
  _move_forward_type move_forward;

   typedef uint8_t _move_backward_type;
  _move_backward_type move_backward;

   typedef uint8_t _move_angle_insertion_type;
  _move_angle_insertion_type move_angle_insertion;

   typedef uint8_t _move_angle_retraction_type;
  _move_angle_retraction_type move_angle_retraction;

   typedef uint8_t _large_gain_type;
  _large_gain_type large_gain;

   typedef uint8_t _small_gain_type;
  _small_gain_type small_gain;

   typedef uint8_t _small_push_type;
  _small_push_type small_push;





  typedef boost::shared_ptr< ::no_rcm_key_publisher_msgs::no_rcm_key_publisher_msgs_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::no_rcm_key_publisher_msgs::no_rcm_key_publisher_msgs_<ContainerAllocator> const> ConstPtr;

}; // struct no_rcm_key_publisher_msgs_

typedef ::no_rcm_key_publisher_msgs::no_rcm_key_publisher_msgs_<std::allocator<void> > no_rcm_key_publisher_msgs;

typedef boost::shared_ptr< ::no_rcm_key_publisher_msgs::no_rcm_key_publisher_msgs > no_rcm_key_publisher_msgsPtr;
typedef boost::shared_ptr< ::no_rcm_key_publisher_msgs::no_rcm_key_publisher_msgs const> no_rcm_key_publisher_msgsConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::no_rcm_key_publisher_msgs::no_rcm_key_publisher_msgs_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::no_rcm_key_publisher_msgs::no_rcm_key_publisher_msgs_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::no_rcm_key_publisher_msgs::no_rcm_key_publisher_msgs_<ContainerAllocator1> & lhs, const ::no_rcm_key_publisher_msgs::no_rcm_key_publisher_msgs_<ContainerAllocator2> & rhs)
{
  return lhs.move_left == rhs.move_left &&
    lhs.move_right == rhs.move_right &&
    lhs.move_up == rhs.move_up &&
    lhs.move_down == rhs.move_down &&
    lhs.move_upward == rhs.move_upward &&
    lhs.move_downward == rhs.move_downward &&
    lhs.move_forward == rhs.move_forward &&
    lhs.move_backward == rhs.move_backward &&
    lhs.move_angle_insertion == rhs.move_angle_insertion &&
    lhs.move_angle_retraction == rhs.move_angle_retraction &&
    lhs.large_gain == rhs.large_gain &&
    lhs.small_gain == rhs.small_gain &&
    lhs.small_push == rhs.small_push;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::no_rcm_key_publisher_msgs::no_rcm_key_publisher_msgs_<ContainerAllocator1> & lhs, const ::no_rcm_key_publisher_msgs::no_rcm_key_publisher_msgs_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace no_rcm_key_publisher_msgs

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsFixedSize< ::no_rcm_key_publisher_msgs::no_rcm_key_publisher_msgs_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::no_rcm_key_publisher_msgs::no_rcm_key_publisher_msgs_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::no_rcm_key_publisher_msgs::no_rcm_key_publisher_msgs_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::no_rcm_key_publisher_msgs::no_rcm_key_publisher_msgs_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::no_rcm_key_publisher_msgs::no_rcm_key_publisher_msgs_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::no_rcm_key_publisher_msgs::no_rcm_key_publisher_msgs_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::no_rcm_key_publisher_msgs::no_rcm_key_publisher_msgs_<ContainerAllocator> >
{
  static const char* value()
  {
    return "c153bb0a32a052ad0d10173dacb72523";
  }

  static const char* value(const ::no_rcm_key_publisher_msgs::no_rcm_key_publisher_msgs_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0xc153bb0a32a052adULL;
  static const uint64_t static_value2 = 0x0d10173dacb72523ULL;
};

template<class ContainerAllocator>
struct DataType< ::no_rcm_key_publisher_msgs::no_rcm_key_publisher_msgs_<ContainerAllocator> >
{
  static const char* value()
  {
    return "no_rcm_key_publisher_msgs/no_rcm_key_publisher_msgs";
  }

  static const char* value(const ::no_rcm_key_publisher_msgs::no_rcm_key_publisher_msgs_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::no_rcm_key_publisher_msgs::no_rcm_key_publisher_msgs_<ContainerAllocator> >
{
  static const char* value()
  {
    return "bool move_left\n"
"bool move_right\n"
"bool move_up\n"
"bool move_down\n"
"bool move_upward\n"
"bool move_downward\n"
"bool move_forward\n"
"bool move_backward\n"
"bool move_angle_insertion\n"
"bool move_angle_retraction\n"
"bool large_gain\n"
"bool small_gain\n"
"bool small_push\n"
;
  }

  static const char* value(const ::no_rcm_key_publisher_msgs::no_rcm_key_publisher_msgs_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::no_rcm_key_publisher_msgs::no_rcm_key_publisher_msgs_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.move_left);
      stream.next(m.move_right);
      stream.next(m.move_up);
      stream.next(m.move_down);
      stream.next(m.move_upward);
      stream.next(m.move_downward);
      stream.next(m.move_forward);
      stream.next(m.move_backward);
      stream.next(m.move_angle_insertion);
      stream.next(m.move_angle_retraction);
      stream.next(m.large_gain);
      stream.next(m.small_gain);
      stream.next(m.small_push);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct no_rcm_key_publisher_msgs_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::no_rcm_key_publisher_msgs::no_rcm_key_publisher_msgs_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::no_rcm_key_publisher_msgs::no_rcm_key_publisher_msgs_<ContainerAllocator>& v)
  {
    s << indent << "move_left: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.move_left);
    s << indent << "move_right: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.move_right);
    s << indent << "move_up: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.move_up);
    s << indent << "move_down: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.move_down);
    s << indent << "move_upward: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.move_upward);
    s << indent << "move_downward: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.move_downward);
    s << indent << "move_forward: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.move_forward);
    s << indent << "move_backward: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.move_backward);
    s << indent << "move_angle_insertion: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.move_angle_insertion);
    s << indent << "move_angle_retraction: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.move_angle_retraction);
    s << indent << "large_gain: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.large_gain);
    s << indent << "small_gain: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.small_gain);
    s << indent << "small_push: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.small_push);
  }
};

} // namespace message_operations
} // namespace ros

#endif // NO_RCM_KEY_PUBLISHER_MSGS_MESSAGE_NO_RCM_KEY_PUBLISHER_MSGS_H
